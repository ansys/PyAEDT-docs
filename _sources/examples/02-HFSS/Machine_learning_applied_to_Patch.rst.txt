
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\02-HFSS\Machine_learning_applied_to_Patch.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_02-HFSS_Machine_learning_applied_to_Patch.py:


HFSS: machine learning applied to a patch
-----------------------------------------
This example shows how you can use PyAEDT to create a machine learning algorithm in three steps:

#. Generate the database.
#. Create the machine learning algorithm.
#. Implement the model in a PyAEDT method.

While this example supplies the code for all three steps in one Python file, it would be
better to separate the code for each step into its own Python file.

.. GENERATED FROM PYTHON SOURCE LINES 14-17

Perform required imports
~~~~~~~~~~~~~~~~~~~~~~~~
Perform required imports.

.. GENERATED FROM PYTHON SOURCE LINES 17-33

.. code-block:: default


    import json
    import os
    import random
    from math import sqrt

    import joblib
    import numpy as np
    from sklearn.pipeline import make_pipeline
    from sklearn.preprocessing import StandardScaler
    from sklearn.svm import SVR

    from pyaedt import Hfss
    from pyaedt.modeler.stackup_3d import Stackup3D









.. GENERATED FROM PYTHON SOURCE LINES 34-39

Set non-graphical mode
~~~~~~~~~~~~~~~~~~~~~~
Set non-graphical mode. ``"PYAEDT_NON_GRAPHICAL"`` is needed to generate
documentation only.
You can set ``non_graphical`` either to ``True`` or ``False``.

.. GENERATED FROM PYTHON SOURCE LINES 39-42

.. code-block:: default


    non_graphical = os.getenv("PYAEDT_NON_GRAPHICAL", "False").lower() in ("true", "1", "t")








.. GENERATED FROM PYTHON SOURCE LINES 43-59

Generate database
-------------------
This section describes the first step, which is for generating the database.

Generate input
~~~~~~~~~~~~~~
Generate input randomly by creating a function with four inputs: frequency,
substrate permittivity, substrate thickness, and patch width. Frequency is
from 0.1 GHz to 1 GHz. Permittivity is from 1 to 12.

The following code generates a database of 1 frequency x 2 permittivity
x 2 thickness x 2 width. It creates eight cases, which are far too few to
use to train the model but are a sufficient number for testing
the model. Later in this example, you import more than 3,300 different 
cases in a previously generated database of 74 frequencies
x 5 permittivity x 3 thickness x 3 width.

.. GENERATED FROM PYTHON SOURCE LINES 59-68

.. code-block:: default


    tuple_random_frequency_permittivity = []
    frequency_list = [150 * 1e6]
    for in_list in frequency_list:
        for i in range(2):
            random_permittivity = 1 + 11 * int(random.random() * 100) / 100
            temp_tuple = (in_list, random_permittivity)
            tuple_random_frequency_permittivity.append(temp_tuple)








.. GENERATED FROM PYTHON SOURCE LINES 69-79

Thickness is generated from 0.0025 to 0.055 of the wavelength in the void.
Width is generated from 0.5 to 1.5 of the optimal theoretical width:

``c / (2 * frequency * sqrt((permittivity + 1) / 2))``

For each couple of frequency-permittivity, three random thicknesses and three
random widths are generated. Patch length is calculated using the analytic
formula. Using this formula is important because it reduces the sweep
frequency needed for the data recovery. Every case is stored in a list of a
dictionary.

.. GENERATED FROM PYTHON SOURCE LINES 79-128

.. code-block:: default


    dictionary_list = []
    c = 2.99792458e8
    for couple in tuple_random_frequency_permittivity:
        list_thickness = []
        list_width = []
        frequency = couple[0]
        permittivity = couple[1]
        er = permittivity
        wave_length_0 = c / frequency

        min_thickness = 0.0025 * wave_length_0
        inter_thickness = 0.01 * wave_length_0
        max_thickness = 0.055 * wave_length_0
        for i in range(2):
            random_int = random.randint(0, 1)
            if random_int == 0:
                thickness = min_thickness + (inter_thickness - min_thickness) * random.random()
            else:
                thickness = inter_thickness + (max_thickness - inter_thickness) * random.random()
            list_thickness.append(thickness)

        min_width = 0.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        max_width = 1.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        for i in range(2):
            width = min_width + (max_width - min_width) * random.random()
            list_width.append(width)

        for width in list_width:
            for thickness in list_thickness:
                effective_permittivity = (er + 1) / 2 + (er - 1) / (2 * sqrt(1 + 10 * thickness / width))
                er_e = effective_permittivity
                w_h = width / thickness
                added_length = 0.412 * thickness * (er_e + 0.3) * (w_h + 0.264) / ((er_e - 0.258) * (w_h + 0.813))
                wave_length = c / (frequency * sqrt(er_e))
                length = wave_length / 2 - 2 * added_length
                dictionary = {
                    "frequency": frequency,
                    "permittivity": permittivity,
                    "thickness": thickness,
                    "width": width,
                    "length": length,
                    "previous_impedance": 0,
                }
                dictionary_list.append(dictionary)

    print("List of data: " + str(dictionary_list))
    print("Its length is: " + str(len(dictionary_list)))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    List of data: [{'frequency': 150000000.0, 'permittivity': 8.15, 'thickness': 0.008447740732875082, 'width': 0.6503281717552754, 'length': 0.34726683542589076, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 8.15, 'thickness': 0.08826455192823279, 'width': 0.6503281717552754, 'length': 0.306787499346326, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 8.15, 'thickness': 0.008447740732875082, 'width': 0.6128463034013668, 'length': 0.347532308444221, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 8.15, 'thickness': 0.08826455192823279, 'width': 0.6128463034013668, 'length': 0.308148016689881, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.17, 'thickness': 0.09069980309950648, 'width': 0.284704490574072, 'length': 0.381655847953573, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.17, 'thickness': 0.04457381710388188, 'width': 0.284704490574072, 'length': 0.400513784873958, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.17, 'thickness': 0.09069980309950648, 'width': 0.5014172237488705, 'length': 0.36522835896972405, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.17, 'thickness': 0.04457381710388188, 'width': 0.5014172237488705, 'length': 0.3886229019950106, 'previous_impedance': 0}]
    Its length is: 8




.. GENERATED FROM PYTHON SOURCE LINES 129-135

Generate HFSS design
~~~~~~~~~~~~~~~~~~~~
Generate the HFSS design using the ``Stackup3D`` method.
Open an HFSS design and create the stackup, add the different layers, and add
the patch. In the stackup library, most things, like the layers and patch,
are already parametrized.

.. GENERATED FROM PYTHON SOURCE LINES 135-148

.. code-block:: default


    desktopVersion = "2022.2"

    hfss = Hfss(
        new_desktop_session=True, solution_type="Terminal", non_graphical=non_graphical, specified_version=desktopVersion
    )

    stackup = Stackup3D(hfss)
    ground = stackup.add_ground_layer("ground", material="copper", thickness=0.035, fill_material="air")
    dielectric = stackup.add_dielectric_layer("dielectric", thickness=10, material="Duroid (tm)")
    signal = stackup.add_signal_layer("signal", material="copper", thickness=0.035, fill_material="air")
    patch = signal.add_patch(patch_length=1009.86, patch_width=1185.9, patch_name="Patch", frequency=100e6)








.. GENERATED FROM PYTHON SOURCE LINES 149-152

Resize layers around patch
~~~~~~~~~~~~~~~~~~~~~~~~~~
Resize the layers around the patch so that they change when the patch changes.

.. GENERATED FROM PYTHON SOURCE LINES 152-155

.. code-block:: default


    stackup.resize_around_element(patch)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True



.. GENERATED FROM PYTHON SOURCE LINES 156-159

Create lumped port
~~~~~~~~~~~~~~~~~~
Create a lumped port that is parametrized with the function of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 159-162

.. code-block:: default


    patch.create_lumped_port(reference_layer=ground, opposite_side=False, port_name="one")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.modules.Boundary.BoundaryObject object at 0x000001FDAA53FBE0>



.. GENERATED FROM PYTHON SOURCE LINES 163-167

Create line
~~~~~~~~~~~
Create a line that is parametrized with the function of the patch length. This
ensures that the air box is large enough in the normal direction of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 167-179

.. code-block:: default


    points_list = [
        [patch.position_x.name, patch.position_y.name, signal.elevation.name],
        [patch.position_x.name, patch.position_y.name, signal.elevation.name + " + " + patch.length.name],
    ]
    hfss.modeler.primitives.create_polyline(position_list=points_list, name="adjust_airbox")
    pad_percent = [50, 50, 300, 50, 50, 10]
    region = hfss.modeler.primitives.create_region(pad_percent)
    hfss.assign_radiation_boundary_to_objects(region)

    hfss.plot(show=False)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.generic.plot.ModelPlotter object at 0x000001FDBFEFD5B0>



.. GENERATED FROM PYTHON SOURCE LINES 180-183

Create setup and sweep
~~~~~~~~~~~~~~~~~~~~~~
Create a setup and a sweep by frequency.

.. GENERATED FROM PYTHON SOURCE LINES 183-211

.. code-block:: default


    print(len(dictionary_list))
    for freq in frequency_list:
        frequency_name = str(int(freq * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        current_setup = hfss.create_setup(setupname=setup_name)
        current_setup.props["Frequency"] = str(freq) + "Hz"
        current_setup.props["MaximumPasses"] = 30
        current_setup.props["MinimumConvergedPasses"] = 2
        current_setup.props["MaxDeltaS"] = 0.05
        current_setup.update()
        current_setup["SaveAnyFields"] = False

        freq_start = freq * 0.75
        freq_stop = freq * 1.25
        sweep_name = "Sweep_of_" + setup_name
        hfss.create_linear_count_sweep(
            setupname=setup_name,
            unit="Hz",
            freqstart=freq_start,
            freqstop=freq_stop,
            num_of_freq_points=25000,
            sweepname="Sweep_of_" + setup_name,
            save_fields=False,
            sweep_type="Interpolating",
        )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    8




.. GENERATED FROM PYTHON SOURCE LINES 212-215

Define function
~~~~~~~~~~~~~~~
Define a function to recover the index of the resonance frequency.

.. GENERATED FROM PYTHON SOURCE LINES 215-239

.. code-block:: default



    def index_of_resonance(imaginary_list, real_list):
        list_of_index = []
        for i in range(1, len(imaginary_list)):
            if imaginary_list[i] * imaginary_list[i - 1] < 0:
                if abs(imaginary_list[i]) < abs(imaginary_list[i - 1]):
                    list_of_index.append(i)
                elif abs(imaginary_list[i]) > abs(imaginary_list[i - 1]):
                    list_of_index.append(i - 1)
        if len(list_of_index) == 0:
            return 0
        elif len(list_of_index) == 1:
            return list_of_index[0]
        else:
            storage = 0
            resonance_index = 0
            for index in list_of_index:
                if storage < real_list[index]:
                    storage = real_list[index]
                    resonance_index = index
            return resonance_index









.. GENERATED FROM PYTHON SOURCE LINES 240-249

Create parametric variation by case
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Use a loop to create a parametric variation by case and associate it with a setup.
The parametric variation is composed of the patch length and width and substrate
permittivity and thickness. For each, measure the real resonance frequency to
obtain the data length, width, permittivity, and thickness that corresponds
to a resonance frequency. Use an error counter to verify that the resonance
frequency is contained in the sweep. To make it easy, calculate the length
of each case using the analytic formula.

.. GENERATED FROM PYTHON SOURCE LINES 249-318

.. code-block:: default


    error_counter = []
    for i in range(len(dictionary_list)):
        dictio = dictionary_list[i]
        frequency_name = str(int(dictio["frequency"] * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        sweep_name = "Sweep_of_" + setup_name
        length_variation = dictio["length"] * 1e3
        width_variation = dictio["width"] * 1e3
        thickness_variation = dictio["thickness"] * 1e3
        permittivity_variation = dictio["permittivity"]
        param_name = "para_" + setup_name + "_" + str(i)
        this_param = hfss.parametrics.add(
            patch.length.name,
            length_variation,
            length_variation,
            step=1,
            variation_type="LinearCount",
            solution=setup_name,
            parametricname=param_name,
        )
        this_param.add_variation(
            patch.width.name, width_variation, width_variation, step=1, unit=None, variation_type="LinearCount"
        )
        this_param.add_variation(
            dielectric.thickness.name,
            thickness_variation,
            thickness_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        this_param.add_variation(
            "$cloned_Duroid__tm__permittivity",
            permittivity_variation,
            permittivity_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        hfss.analyze_setup(param_name, num_cores=4, num_tasks=None)
        data = hfss.post.get_solution_data(
            "Zt(one_T1, one_T1)",
            setup_sweep_name=setup_name + " : " + sweep_name,
            domain="Sweep",
            variations={
                patch.length.name: [str(length_variation) + "mm"],
                patch.width.name: [str(width_variation) + "mm"],
                dielectric.thickness.name: [str(thickness_variation) + "mm"],
                "$cloned_Duroid__tm__permittivity": [str(permittivity_variation)],
            },
            polyline_points=25000,
        )
        imaginary_part = data.data_imag()
        real_part = data.data_real()
        corresponding_index = index_of_resonance(imaginary_part, real_part)
        if corresponding_index == 0:
            hfss.logger.error("The resonance is out of the range")
            error_counter.append(i)
        minimum_imaginary = imaginary_part[corresponding_index]
        previous_impedance = real_part[corresponding_index]
        print("minimum_imaginary: " + str(minimum_imaginary))
        print("previous_impedance: " + str(previous_impedance))
        frequency_list = data.primary_sweep_values
        resonance_frequency = frequency_list[corresponding_index]
        print(resonance_frequency)
        dictio["frequency"] = resonance_frequency
        dictio["previous_impedance"] = previous_impedance





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    minimum_imaginary: -0.264323529665486
    previous_impedance: 202.61419957120157
    0.13796801872074899
    minimum_imaginary: 0.03141039692564916
    previous_impedance: 205.8387956746612
    0.134757890315613
    minimum_imaginary: -1.010057150632033
    previous_impedance: 223.30629852383368
    0.138493039721589
    minimum_imaginary: -0.06717981532913242
    previous_impedance: 208.67217720378832
    0.134166866674667
    minimum_imaginary: 0.06240443430822693
    previous_impedance: 303.76951152241884
    0.134052862114485
    minimum_imaginary: -0.12170872714293868
    previous_impedance: 332.0377657216604
    0.138010020400816
    minimum_imaginary: -0.03292558453335935
    previous_impedance: 232.5592084371949
    0.134841893675747
    minimum_imaginary: 0.10032338341895718
    previous_impedance: 273.1801090831435
    0.13921306852274098




.. GENERATED FROM PYTHON SOURCE LINES 319-322

Print error
~~~~~~~~~~~
Print the number of range error.

.. GENERATED FROM PYTHON SOURCE LINES 322-325

.. code-block:: default


    print("number of range error: " + str(error_counter))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of range error: []




.. GENERATED FROM PYTHON SOURCE LINES 326-330

End data recovery step
~~~~~~~~~~~~~~~~~~~~~~
End the data recovery step by dumping the dictionary list into a JSON file.
Saving the data allows you to use it in another Python script.

.. GENERATED FROM PYTHON SOURCE LINES 330-335

.. code-block:: default


    json_file_path = os.path.join(hfss.working_directory, "ml_data_for_test.json")
    with open(json_file_path, "w") as readfile:
        json.dump(dictionary_list, readfile)








.. GENERATED FROM PYTHON SOURCE LINES 336-346

Create machine learning algorithm
----------------------------------
This section describes the second step, which is for creating the machine
learning algorithm.

Import training cases
~~~~~~~~~~~~~~~~~~~~~
Import the 3,300 cases in the supplied JSON file to train the model. As mentioned
earlier, you cannot use the small database that you generated earlier for training
the model. Its 8 cases are used later to test the model.

.. GENERATED FROM PYTHON SOURCE LINES 346-358

.. code-block:: default


    path_folder = hfss.pyaedt_dir
    training_file = os.path.join(path_folder, "misc", "ml_data_file_train_100MHz_1GHz.json")
    with open(training_file) as readfile:
        my_dictio_list_train = json.load(readfile)

    with open(json_file_path, "r") as readfile:
        my_dictio_list_test = json.load(readfile)

    print(len(my_dictio_list_train))
    print(len(my_dictio_list_test))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    3330
    8




.. GENERATED FROM PYTHON SOURCE LINES 359-367

Create lists
~~~~~~~~~~~~
Create four lists:

- One for the input of the training
- One for the output of training
- Oone for the input of the test
- One for the output of the test

.. GENERATED FROM PYTHON SOURCE LINES 367-374

.. code-block:: default



    input_for_training_list = []
    output_for_training_list = []
    input_for_test_list = []
    output_for_test_list = []








.. GENERATED FROM PYTHON SOURCE LINES 375-380

Fill list for input of training
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Fill the list for the input of the training with frequency, width, permittivity,
and thickness so that the output is the length. The objective of this
algorithm is to predict the length according to the rest.

.. GENERATED FROM PYTHON SOURCE LINES 380-406

.. code-block:: default


    for i in range(len(my_dictio_list_train)):
        freq_width_perm_thick = [
            my_dictio_list_train[i]["frequency"] * 1e9,
            my_dictio_list_train[i]["width"] * 1000,
            my_dictio_list_train[i]["permittivity"],
            my_dictio_list_train[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_train[i]["length"] * 1000
        input_for_training_list.append(freq_width_perm_thick)
        output_for_training_list.append(length)

    for i in range(len(my_dictio_list_test)):
        freq_width_perm_thick = [
            my_dictio_list_test[i]["frequency"] * 1e9,
            my_dictio_list_test[i]["width"] * 1000,
            my_dictio_list_test[i]["permittivity"],
            my_dictio_list_test[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_test[i]["length"] * 1000
        input_for_test_list.append(freq_width_perm_thick)
        output_for_test_list.append(length)

    print("number of test cases: " + str(len(output_for_test_list)))
    print("number of training cases: " + str(len(output_for_training_list)))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of test cases: 8
    number of training cases: 3330




.. GENERATED FROM PYTHON SOURCE LINES 407-410

Convert lists in array
~~~~~~~~~~~~~~~~~~~~~~
Convert the lists in an array.

.. GENERATED FROM PYTHON SOURCE LINES 410-419

.. code-block:: default


    input_for_training_array = np.array(input_for_training_list, dtype=np.float32)
    output_for_training_array = np.array(output_for_training_list, dtype=np.float32)
    input_for_test_array = np.array(input_for_test_list, dtype=np.float32)
    output_for_test_array = np.array(output_for_test_list, dtype=np.float32)

    print("input array for training: " + str(input_for_training_array))
    print("output array for training: " + str(output_for_training_array))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input array for training: [[8.5343952e+07 1.8699978e+03 1.0000000e+00 1.3607236e+02]
     [8.7562560e+07 1.8699978e+03 1.0000000e+00 3.1649155e+01]
     [8.5523544e+07 1.8699978e+03 1.0000000e+00 1.6327014e+02]
     ...
     [9.5384678e+08 3.3421940e+01 1.1450000e+01 1.0995456e+01]
     [1.1057147e+09 3.3421940e+01 1.1450000e+01 2.1035936e+00]
     [9.7680755e+08 3.3421940e+01 1.1450000e+01 1.3259815e+01]]
    output array for training: [1463.626    1607.3876   1427.5016   ...   36.353287   39.326664
       35.355724]




.. GENERATED FROM PYTHON SOURCE LINES 420-440

Create model
~~~~~~~~~~~~
Create the model. Depending on the app, you can use different models.
The easiest way to find the correct model for an app is to search
for this app or one that is close to it.

To predict characteristics of a patch antenna (resonance frequency, bandwidth,
and input impedance), you can use SVR (Support Vector Regression) or ANN
(Analyze Neuronal Network). The following code uses SVR because it is easier
to implement. ANN is a more general method that also works with other
high frequency components. While it is more likely to work for other app,
implementing ANN is much more complex.

For SVR, there are three different kernels. For the patch antenna, RBF (Radial Basic
Function) is preferred. There are three other arguments that have a big impact
on the accuracy of the model: C, gamma, and epsilon. Sometimes they are given
with the necessary model for the app. Otherwise, you can try different
values and see which one is the best by measuring the accuracy of the model.
To make this example shorter, ``C=1e4``. However, the optimal value
in this app is ``C=5e4``.

.. GENERATED FROM PYTHON SOURCE LINES 440-444

.. code-block:: default


    svr_rbf = SVR(kernel="rbf", C=1e4, gamma="auto", epsilon=0.05)
    regression = make_pipeline(StandardScaler(), svr_rbf)








.. GENERATED FROM PYTHON SOURCE LINES 445-448

Train model
~~~~~~~~~~~
Train the model.

.. GENERATED FROM PYTHON SOURCE LINES 448-451

.. code-block:: default


    regression.fit(input_for_training_array, output_for_training_array)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" ><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" ><label for="sk-estimator-id-2" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler()</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" ><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">SVR</label><div class="sk-toggleable__content"><pre>SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;)</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 452-456

Dump model into JOBLIB file
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Dump the model into a JOBLIB file using the same method as you used earlier
for the JSON file.

.. GENERATED FROM PYTHON SOURCE LINES 456-460

.. code-block:: default


    model_file = os.path.join(hfss.working_directory, "svr_model.joblib")
    joblib.dump(regression, model_file)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['D:/Project/Project943.pyaedt\\HFSS_NLU\\svr_model.joblib']



.. GENERATED FROM PYTHON SOURCE LINES 461-471

Implement model in PyAEDT method
-------------------------------------
This section describes the third step, which is for implementing the model
in the PyAEDT method.

Load model
~~~~~~~~~~
Load the model in another Python file to predict different cases.
Here the correct model with ``C=5e4`` is loaded rather than the one you made
earlier with ``C=1e4``.

.. GENERATED FROM PYTHON SOURCE LINES 471-475

.. code-block:: default


    model_path = os.path.join(path_folder, "misc", "patch_svr_model_100MHz_1GHz.joblib")
    regression = joblib.load(model_path)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator StandardScaler from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator SVR from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator Pipeline from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(




.. GENERATED FROM PYTHON SOURCE LINES 476-480

Predict length of patch
~~~~~~~~~~~~~~~~~~~~~~~
Predict the length of the patch as a function of its resonant frequency and width
and substrate thickness and permittivity.

.. GENERATED FROM PYTHON SOURCE LINES 480-483

.. code-block:: default


    prediction_of_length = regression.predict(input_for_test_list)








.. GENERATED FROM PYTHON SOURCE LINES 484-487

Measure model efficiency
~~~~~~~~~~~~~~~~~~~~~~~~
Measure the model efficiency.

.. GENERATED FROM PYTHON SOURCE LINES 487-539

.. code-block:: default


    average_relative_gap = 0
    counter_under_zero_five = 0
    counter_under_one = 0
    counter_under_two = 0
    counter_under_five = 0
    counter_under_ten = 0
    counter_upper_ten = 0
    rel_counter_under_one = 0
    rel_counter_under_two = 0
    rel_counter_under_five = 0
    rel_counter_under_ten = 0
    rel_counter_under_twenty = 0
    rel_counter_upper_twenty = 0
    for index in range(len(prediction_of_length)):
        print(
            "value: "
            + str(input_for_test_list[index])
            + ", prediction: "
            + str(prediction_of_length[index] * 1000)
            + ", reality: "
            + str(output_for_test_list[index] * 1000)
        )
        gap = abs(prediction_of_length[index] - output_for_test_list[index])
        relative_gap = gap / output_for_test_list[index]
        average_relative_gap = average_relative_gap + relative_gap
        if gap < 0.5:
            counter_under_zero_five += 1
        elif 0.5 <= gap < 1:
            counter_under_one += 1
        elif 1 <= gap < 2:
            counter_under_two += 1
        elif 2 <= gap < 5:
            counter_under_five += 1
        elif 5 <= gap < 10:
            counter_under_ten += 1
        else:
            counter_upper_ten += 1
        if relative_gap < 0.01:
            rel_counter_under_one += 1
        elif relative_gap < 0.02:
            rel_counter_under_two += 1
        elif relative_gap < 0.05:
            rel_counter_under_five += 1
        elif relative_gap < 0.1:
            rel_counter_under_ten += 1
        elif relative_gap < 0.2:
            rel_counter_under_twenty += 1
        else:
            rel_counter_upper_twenty += 1
    average_relative_gap = average_relative_gap / len(prediction_of_length)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    value: [137968018.720749, 650.3281717552753, 8.15, 8.447740732875083], prediction: 351307.06556243595, reality: 347266.83542589075
    value: [134757890.315613, 650.3281717552753, 8.15, 88.26455192823279], prediction: 287805.4102379167, reality: 306787.499346326
    value: [138493039.721589, 612.8463034013668, 8.15, 8.447740732875083], prediction: 345043.439268856, reality: 347532.30844422104
    value: [134166866.67466702, 612.8463034013668, 8.15, 88.26455192823279], prediction: 291600.37724106415, reality: 308148.016689881
    value: [134052862.114485, 284.704490574072, 6.17, 90.69980309950648], prediction: 409996.35601292935, reality: 381655.84795357304
    value: [138010020.400816, 284.704490574072, 6.17, 44.57381710388188], prediction: 404750.73999171716, reality: 400513.784873958
    value: [134841893.675747, 501.4172237488705, 6.17, 90.69980309950648], prediction: 368978.654205093, reality: 365228.3589697241
    value: [139213068.522741, 501.4172237488705, 6.17, 44.57381710388188], prediction: 399062.4155949944, reality: 388622.90199501056




.. GENERATED FROM PYTHON SOURCE LINES 540-542

The first displays are the gap ``(prediction - real)``. The second displays are
the relative gap ``((prediction - real)/real)``.

.. GENERATED FROM PYTHON SOURCE LINES 542-582

.. code-block:: default


    print("sample size: " + str(len(prediction_of_length)))
    print("<0.5 : " + str(counter_under_zero_five))
    print("<1 : " + str(counter_under_one))
    print("<2 : " + str(counter_under_two))
    print("<5 : " + str(counter_under_five))
    print("<10 : " + str(counter_under_ten))
    print(">10 : " + str(counter_upper_ten) + "\n")
    print(
        "sum : "
        + str(
            counter_under_zero_five
            + counter_under_one
            + counter_under_two
            + counter_under_five
            + counter_under_ten
            + counter_upper_ten
        )
    )

    print("-------------------------------------------\n")
    print("<0.01 : " + str(rel_counter_under_one))
    print("<0.02 : " + str(rel_counter_under_two))
    print("<0.05 : " + str(rel_counter_under_five))
    print("<0.1 : " + str(rel_counter_under_ten))
    print("<0.2 : " + str(rel_counter_under_twenty))
    print(">0.2 : " + str(rel_counter_upper_twenty))
    print(
        "sum : "
        + str(
            rel_counter_under_one
            + rel_counter_under_two
            + rel_counter_under_five
            + rel_counter_under_ten
            + rel_counter_under_twenty
            + rel_counter_upper_twenty
        )
    )
    print("average is : " + str(average_relative_gap))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    sample size: 8
    <0.5 : 0
    <1 : 0
    <2 : 0
    <5 : 4
    <10 : 0
    >10 : 4

    sum : 8
    -------------------------------------------

    <0.01 : 1
    <0.02 : 3
    <0.05 : 1
    <0.1 : 3
    <0.2 : 0
    >0.2 : 0
    sum : 8
    average is : 0.03204208159508773




.. GENERATED FROM PYTHON SOURCE LINES 583-586

Release AEDT
------------
Release AEDT.

.. GENERATED FROM PYTHON SOURCE LINES 586-588

.. code-block:: default


    hfss.release_desktop()




.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 8 minutes  12.865 seconds)


.. _sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: Machine_learning_applied_to_Patch.py <Machine_learning_applied_to_Patch.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: Machine_learning_applied_to_Patch.ipynb <Machine_learning_applied_to_Patch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
